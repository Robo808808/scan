 ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
 ‚îÇ   Primary Database (DBPRIM)  ‚îÇ        ‚îÇ  Standby Database (DBSTBY) ‚îÇ
 ‚îÇ   ORACLE_HOME: /u01/app/19c  ‚îÇ‚óÑ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫‚îÇ  ORACLE_HOME: /u01/app/19c ‚îÇ
 ‚îÇ   Role: PRIMARY              ‚îÇ   Redo ‚îÇ  Role: PHYSICAL STANDBY    ‚îÇ
 ‚îÇ   Service: APP_TAC           ‚îÇ        ‚îÇ  FSFO target               ‚îÇ
 ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò        ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
            ‚îÇ                                       ‚îÇ
            ‚îÇ  Broker Managed + Observer (FSFO)     ‚îÇ
            ‚îÇ                                       ‚îÇ
            ‚ñº                                       ‚ñº
     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
     ‚îÇ Observer / Client   ‚îÇ                    ‚îÇ Swingbench Driver   ‚îÇ
     ‚îÇ Location: 3rd host  ‚îÇ                    ‚îÇ JDBC/UCP TAC driver ‚îÇ
     ‚îÇ FAN/ONS enabled     ‚îÇ                    ‚îÇ Queries continuously‚îÇ
     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò


Step 1: Create Primary Database

alter database force logging;
alter system set log_archive_dest_1='LOCATION=/u01/arch';

Step 2: Configure Data Guard
Primary:
rman target /
run {
  allocate channel c1 device type disk;
  backup as copy database format '/u01/backup/%U';
}
Standby:
rman target sys@dbprim auxiliary /
duplicate target database for standby from active database;
Primary
dgmgrl sys@dbprim
DGMGRL> create configuration 'dgconf' as primary database is dbprim connect identifier is dbprim;
DGMGRL> add database dbstby as connect identifier is dbstby maintained as physical;
DGMGRL> enable configuration;

Step 3: Enable Fast Start Failover (FSFO)

DGMGRL> enable fast_start failover;
DGMGRL> start observer;

dgmgrl sys@dbprim "start observer file=/u01/observerfsfo/observer.dat"      -- on third host

Step 4: Configure Transparent Application Continuity (TAC)

srvctl add service -db dbprim -service app_tac \
  -role PRIMARY \
  -preferred dbprim \
  -available dbstby \
  -failovertype TRANSPARENT \
  -failover_restore LEVEL \
  -commit_outcome TRUE \
  -replay_init_time 1800 \
  -retention 86400 \
  -notification TRUE

srvctl start service -db dbprim -service app_tac


-- Drop the service if it already exists
BEGIN
  DBMS_SERVICE.DELETE_SERVICE('app_tac');
EXCEPTION WHEN OTHERS THEN
  IF SQLCODE != -44303 THEN RAISE; END IF;
END;
/

-- Create TAC-enabled service
BEGIN
  DBMS_SERVICE.CREATE_SERVICE(
    service_name        => 'app_tac',
    network_name        => 'app_tac',
    aq_ha_notifications => TRUE,
    commit_outcome      => TRUE,
    failover_restore    => 'LEVEL',
    role                => 'PRIMARY'          -- string literal, not constant
  );

  DBMS_SERVICE.MODIFY_SERVICE(
    service_name   => 'app_tac',
    failover_type  => 'TRANSPARENT'           -- string literal
  );
END;
/

-- Role-based startup trigger
CREATE OR REPLACE TRIGGER manage_app_tac_service
AFTER STARTUP ON DATABASE
DECLARE
  v_role VARCHAR2(30);
BEGIN
  SELECT DATABASE_ROLE INTO v_role FROM V$DATABASE;
  IF v_role = 'PRIMARY' THEN
    DBMS_SERVICE.START_SERVICE('app_tac');
  ELSE
    DBMS_SERVICE.STOP_SERVICE('app_tac');
  END IF;
END;
/

-- Check
COL name FORMAT A12
COL failover_type FORMAT A15
COL failover_restore FORMAT A15
COL commit_outcome FORMAT A10
SELECT name, failover_type, failover_restore, commit_outcome
FROM   dba_services
WHERE  name = 'APP_TAC';


BEGIN
  DBMS_SERVICE.DELETE_SERVICE('app_tac');
EXCEPTION WHEN OTHERS THEN
  IF SQLCODE != -44303 THEN RAISE; END IF;
END;
/

BEGIN
  DBMS_SERVICE.CREATE_SERVICE(
    service_name        => 'app_tac',
    network_name        => 'app_tac',
    aq_ha_notifications => TRUE,
    commit_outcome      => TRUE,
    failover_restore    => 'LEVEL',
    role                => 'PHYSICAL STANDBY'   -- string literal
  );

  DBMS_SERVICE.MODIFY_SERVICE(
    service_name   => 'app_tac',
    failover_type  => 'TRANSPARENT'
  );
END;
/

CREATE OR REPLACE TRIGGER manage_app_tac_service
AFTER STARTUP ON DATABASE
DECLARE
  v_role VARCHAR2(30);
BEGIN
  SELECT DATABASE_ROLE INTO v_role FROM V$DATABASE;
  IF v_role = 'PHYSICAL STANDBY' THEN
    DBMS_SERVICE.START_SERVICE('app_tac');
  ELSE
    DBMS_SERVICE.STOP_SERVICE('app_tac');
  END IF;
END;
/

SELECT name, role, failover_type, failover_restore, commit_outcome
FROM   dba_services
WHERE  name='APP_TAC';



-- SHOW PARAMETER local_listener

The aq_ha_notifications => TRUE above lets the DB publish HA events. Some clients (OCI/ODP.NET) consume from AQ directly when notification=TRUE;
docs show the server-side bit typically via srvctl, but with DBMS_SERVICE the notification property is covered by AQ HA notifications.

For Java UCP clients, the most reliable approach is to also run ONS daemons on each DB host and point UCP at them:

$ORACLE_HOME/bin/onsctl start

In your JBoss/WebSphere datasource, set:
oracle.ons.nodes=dbprim:6200,dbstby1:6200,dbstby2:6200,dbstby3:6200
oracle.jdbc.fanEnabled=true

5) Client connect string stays the same

jdbc:oracle:thin:@(DESCRIPTION=
 (ADDRESS_LIST=(ADDRESS=(PROTOCOL=TCP)(HOST=dbprim)(PORT=1521))
               (ADDRESS=(PROTOCOL=TCP)(HOST=dbstby1)(PORT=1521)))
 (CONNECT_DATA=(SERVICE_NAME=app_tac)))


select name, failover_type, failover_restore, commit_outcome
from dba_services where name='APP_TAC';

Step 5: Enable ONS/FAN

On both DB nodes:
Add to $ORACLE_HOME/opmn/conf/ons.config (if standalone) or via srvctl modify service -notification TRUE
Ensure port (default 6200) is open.

Example on client:
export ONS_CONFIG="nodes=dbprim:6200,dbstby:6200"

Step 6: Configure Client with UCP + TAC
Edit swingconfig.xml connection string:
<connection-string>
  jdbc:oracle:thin:@(DESCRIPTION=
    (ADDRESS_LIST=
      (ADDRESS=(PROTOCOL=TCP)(HOST=dbprim)(PORT=1521))
      (ADDRESS=(PROTOCOL=TCP)(HOST=dbstby)(PORT=1521)))
    (CONNECT_DATA=(SERVICE_NAME=app_tac)))
</connection-string>

-- set properties for TAC
<property name="oracle.net.ns.SQLnetDef.TAC" value="true"/>
<property name="oracle.jdbc.fanEnabled" value="true"/>
<property name="oracle.jdbc.replayInitiationTimeout" value="1800"/>

-- start swingbench
./charbench -c ./swingconfig.xml -ucp -v users,tpm


Step 7: Validate Zero-Downtime Failover
DGMGRL> switchover to dbstby;
sudo pkill -9 -f pmon_dbprim
(FSFO wil auto failover in second-case)

Step 8: Transient Logical Standby Upgrade (for patch demo)
DGMGRL> convert database dbstby to snapshot standby;


üß© 2. Typical MAA Zero-Downtime Upgrade Flow with AutoUpgrade

Step 1  Primary: DBPRIM    | Version 19.15
         Standby: DBSTBY   | Version 19.15
         FSFO Observer running
         TAC Service: APP_TAC

Step 2  Prepare patched Oracle Home on standby host
         e.g. /u01/app/oracle/product/19.21.0/dbhome_2

Step 3  Convert standby to transient logical standby
         DGMGRL> convert database dbstby to snapshot standby;
         (or to transient logical using TLS script)

Step 4  Run AutoUpgrade on the standby (in deploy mode)
         java -jar $ORACLE_HOME/rdbms/admin/autoupgrade.jar \
              -config /home/oracle/autoupgrade_tls.cfg \
              -mode deploy

Step 5  Validate upgraded standby
         DGMGRL> convert database dbstby to physical standby;
         Redo apply resumes

Step 6  Perform switchover
         DGMGRL> switchover to dbstby;
         Clients continue via TAC with no outage

Step 7  Upgrade former primary using AutoUpgrade
         (same config file, different home path)

Step 8  Reinstate as standby
         DGMGRL> reinstate database dbprim;

üß∞ 3. Example AutoUpgrade Configuration for This Scenario

global.autoupg_log_dir=/u01/app/autoupgrade/logs
global.raise_compatibility=yes

upg1.source_home=/u01/app/oracle/product/19.15.0/dbhome_1
upg1.target_home=/u01/app/oracle/product/19.21.0/dbhome_2
upg1.sid=DBSTBY
upg1.log_dir=/u01/app/autoupgrade/dbstby
upg1.upgrade_node=dbstby
upg1.start_time=immediate
upg1.target_version=19.21
upg1.run_utlrp=yes
upg1.timezone_upg=yes
upg1.restoration=no

$ java -jar $ORACLE_HOME/rdbms/admin/autoupgrade.jar -config /home/oracle/autoupgrade_tls.cfg -mode deploy

5. Advanced Option ‚Äî Use AutoUpgrade in ‚ÄúDual Mode‚Äù

AutoUpgrade has a -mode deploy -n 2 syntax that lets you upgrade two databases sequentially ‚Äî
e.g. first standby, then primary ‚Äî using one config file.
This can fully automate the rolling upgrade sequence if combined with pre- and post-actions that call Data Guard switchover commands.


üéØ 10. Example Demo Sequence (Scripted Overview)

# Prepare transient standby
dgmgrl sys@dbprim "convert database dbstby to transient logical standby"

# Run AutoUpgrade on dbstby
java -jar /u01/app/oracle/product/19.15.0/dbhome_1/rdbms/admin/autoupgrade.jar \
  -config /home/oracle/autoupgrade_tls.cfg -mode deploy

# Switchover after upgrade
dgmgrl sys@dbprim "switchover to dbstby"

# Run AutoUpgrade on old primary
java -jar /u01/app/oracle/product/19.15.0/dbhome_1/rdbms/admin/autoupgrade.jar \
  -config /home/oracle/autoupgrade_dbprim.cfg -mode deploy

# Reinstate and resume
dgmgrl sys@dbstby "reinstate database dbprim"
