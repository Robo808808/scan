 ┌──────────────────────────────┐        ┌────────────────────────────┐
 │   Primary Database (DBPRIM)  │        │  Standby Database (DBSTBY) │
 │   ORACLE_HOME: /u01/app/19c  │◄──────►│  ORACLE_HOME: /u01/app/19c │
 │   Role: PRIMARY              │   Redo │  Role: PHYSICAL STANDBY    │
 │   Service: APP_TAC           │        │  FSFO target               │
 └──────────┬───────────────────┘        └──────────┬─────────────────┘
            │                                       │
            │  Broker Managed + Observer (FSFO)     │
            │                                       │
            ▼                                       ▼
     ┌─────────────────────┐                    ┌─────────────────────┐
     │ Observer / Client   │                    │ Swingbench Driver   │
     │ Location: 3rd host  │                    │ JDBC/UCP TAC driver │
     │ FAN/ONS enabled     │                    │ Queries continuously│
     └─────────────────────┘                    └─────────────────────┘


Step 1: Create Primary Database

alter database force logging;
alter system set log_archive_dest_1='LOCATION=/u01/arch';

Step 2: Configure Data Guard
Primary:
rman target /
run {
  allocate channel c1 device type disk;
  backup as copy database format '/u01/backup/%U';
}
Standby:
rman target sys@dbprim auxiliary /
duplicate target database for standby from active database;
Primary
dgmgrl sys@dbprim
DGMGRL> create configuration 'dgconf' as primary database is dbprim connect identifier is dbprim;
DGMGRL> add database dbstby as connect identifier is dbstby maintained as physical;
DGMGRL> enable configuration;

Step 3: Enable Fast Start Failover (FSFO)

DGMGRL> enable fast_start failover;
DGMGRL> start observer;

dgmgrl sys@dbprim "start observer file=/u01/observerfsfo/observer.dat"      -- on third host

Step 4: Configure Transparent Application Continuity (TAC)

srvctl add service -db dbprim -service app_tac \
  -role PRIMARY \
  -preferred dbprim \
  -available dbstby \
  -failovertype TRANSPARENT \
  -failover_restore LEVEL \
  -commit_outcome TRUE \
  -replay_init_time 1800 \
  -retention 86400 \
  -notification TRUE

srvctl start service -db dbprim -service app_tac


-- Drop the service if it already exists
BEGIN
  DBMS_SERVICE.DELETE_SERVICE('app_tac');
EXCEPTION WHEN OTHERS THEN
  IF SQLCODE != -44303 THEN RAISE; END IF;
END;
/

-- app_tac_service.sql  (run as SYS in CDB$ROOT or target PDB)

SET SERVEROUTPUT ON
DECLARE
  v_exists NUMBER;
BEGIN
  SELECT COUNT(*) INTO v_exists FROM dba_services WHERE name = 'APP_TAC';
  IF v_exists = 0 THEN
    DBMS_SERVICE.CREATE_SERVICE(
      service_name => 'app_tac',
      network_name => 'app_tac'
    );
    DBMS_OUTPUT.PUT_LINE('Created service APP_TAC');
  ELSE
    DBMS_OUTPUT.PUT_LINE('Service APP_TAC already exists');
  END IF;
END;
/

-- Use the parameter-array overload for TAC/AC attributes (portable on 19c)
DECLARE
  params DBMS_SERVICE.svc_parameter_array;
BEGIN
  -- TAC/AC essentials
  params('FAILOVER_TYPE')             := 'AUTO';       -- TAC (use 'TRANSACTION' for AC)
  params('FAILOVER_RESTORE')          := 'AUTO';       -- TAC (use 'LEVEL1' for AC)
  params('COMMIT_OUTCOME')            := 'true';       -- enable Transaction Guard
  params('REPLAY_INITIATION_TIMEOUT') := 1800;         -- seconds
  params('RETENTION_TIMEOUT')         := 86400;        -- seconds (24h)

  -- FAN / drain (optional but recommended)
  params('AQ_HA_NOTIFICATIONS')       := 'true';
  params('DRAIN_TIMEOUT')             := 60;           -- graceful stop/relocate window
  params('STOP_OPTION')               := 'TRANSACTIONAL';

  -- Reasonable connect retry pacing (optional)
  params('FAILOVER_DELAY')            := 10;
  params('FAILOVER_RETRIES')          := 30;

  DBMS_SERVICE.MODIFY_SERVICE('app_tac', params);
  DBMS_OUTPUT.PUT_LINE('Modified service APP_TAC (TAC attributes applied)');
END;
/

-- Start/stop by role immediately on role change (no GI required) on CD$ROOT
CREATE OR REPLACE TRIGGER app_tac_role_change_trg
AFTER DB_ROLE_CHANGE ON DATABASE
DECLARE
  v_role VARCHAR2(30);
BEGIN
  SELECT database_role INTO v_role FROM v$database;
  IF v_role = 'PRIMARY' THEN
    DBMS_SERVICE.START_SERVICE('app_tac');
  ELSE
    -- If you want RO on standby, change to START_SERVICE here
    DBMS_SERVICE.STOP_SERVICE('app_tac');
  END IF;
END;
/

-- Also handle normal instance restarts
CREATE OR REPLACE TRIGGER app_tac_startup_trg
AFTER STARTUP ON DATABASE
DECLARE
  v_role VARCHAR2(30);
BEGIN
  SELECT database_role INTO v_role FROM v$database;
  IF v_role = 'PRIMARY' THEN
    DBMS_SERVICE.START_SERVICE('app_tac');
  ELSE
    DBMS_SERVICE.STOP_SERVICE('app_tac');
  END IF;
END;
/

-- Start/stop the service when THIS PDB opens, based on database role
CREATE OR REPLACE TRIGGER app_tac_pdb_open_trg
AFTER OPEN ON PLUGGABLE DATABASE
DECLARE
  v_role      VARCHAR2(30);
  v_open_mode VARCHAR2(20);
BEGIN
  SELECT database_role, open_mode
    INTO v_role, v_open_mode
    FROM v$database;

  -- Start on PRIMARY; optionally start on ADG read-only too
  IF v_role = 'PRIMARY' THEN
    DBMS_SERVICE.START_SERVICE('app_tac');
  ELSIF v_role = 'PHYSICAL STANDBY' AND v_open_mode LIKE 'READ ONLY%' THEN
    -- If you want the APP_TAC service available on an ADG read-only standby, keep this START; otherwise STOP
    DBMS_SERVICE.START_SERVICE('app_tac');
  ELSE
    DBMS_SERVICE.STOP_SERVICE('app_tac');
  END IF;
END;
/


-- Verify
COLUMN name FORMAT A12
COLUMN failover_type FORMAT A10
COLUMN commit_outcome FORMAT A6
SELECT name, failover_type, failover_restore, commit_outcome
FROM   dba_services
WHERE  name = 'APP_TAC';


-- 4) Verify
SELECT name, failover_type, failover_restore, commit_outcome
FROM   dba_services
WHERE  name='APP_TAC';




1) SQL script to manage the service (runs as SYSDBA)
-- manage_app_tac.sql  (plain 19c SI; run via sqlplus / as sysdba)
-- Args: define PDB_NAME before calling (e.g., DEFINE PDB_NAME=MYAPP)

SET SERVEROUTPUT ON FEEDBACK OFF VERIFY OFF HEADING OFF LINES 200 PAGES 0
WHENEVER SQLERROR EXIT 1

DECLARE
  v_role       VARCHAR2(30);
  v_open_mode  VARCHAR2(20);
  v_exists     NUMBER;
  -- helper to apply TAC/AC attributes via the parameter-array overload
  PROCEDURE apply_tac IS
    p DBMS_SERVICE.svc_parameter_array;
  BEGIN
    -- TAC/AC essentials (portable keys)
    p('FAILOVER_TYPE')             := 'AUTO';      -- TAC (AUTO/TXN replay)
    p('FAILOVER_RESTORE')          := 'AUTO';      -- TAC state restore
    p('COMMIT_OUTCOME')            := 'true';      -- Transaction Guard
    p('REPLAY_INITIATION_TIMEOUT') := 1800;        -- seconds
    p('RETENTION_TIMEOUT')         := 86400;       -- seconds (24h)
    -- FAN/drain (optional)
    p('AQ_HA_NOTIFICATIONS')       := 'true';
    p('DRAIN_TIMEOUT')             := 60;
    p('STOP_OPTION')               := 'TRANSACTIONAL';
    -- retry pacing (optional)
    p('FAILOVER_DELAY')            := 10;
    p('FAILOVER_RETRIES')          := 30;

    DBMS_SERVICE.MODIFY_SERVICE('app_tac', p);
  END;
BEGIN
  -- Check DG role (in ROOT)
  SELECT database_role INTO v_role FROM v$database;

  -- Switch into target PDB
  EXECUTE IMMEDIATE 'alter session set container=&PDB_NAME';

  -- Make sure PDB is open (READ WRITE or ADG READ ONLY)
  SELECT open_mode INTO v_open_mode FROM v$database;

  -- Ensure service exists
  SELECT COUNT(*) INTO v_exists FROM dba_services WHERE name='APP_TAC';
  IF v_exists = 0 THEN
    DBMS_SERVICE.CREATE_SERVICE(service_name=>'app_tac', network_name=>'app_tac');
  END IF;

  -- Apply TAC attributes (safe on 19c SI)
  apply_tac;

  -- Start/stop by role + PDB mode
  IF v_role = 'PRIMARY' AND (v_open_mode LIKE 'READ WRITE' OR v_open_mode LIKE 'READ ONLY%') THEN
    DBMS_SERVICE.START_SERVICE('app_tac');
    DBMS_OUTPUT.PUT_LINE('APP_TAC started in &PDB_NAME (PRIMARY)');
  ELSIF v_role = 'PHYSICAL STANDBY' AND v_open_mode LIKE 'READ ONLY%' THEN
    -- If you DO NOT want the service on ADG read-only, change to STOP_SERVICE here.
    DBMS_SERVICE.START_SERVICE('app_tac');
    DBMS_OUTPUT.PUT_LINE('APP_TAC started in &PDB_NAME (ADG RO)');
  ELSE
    BEGIN
      DBMS_SERVICE.STOP_SERVICE('app_tac');
      DBMS_OUTPUT.PUT_LINE('APP_TAC stopped in &PDB_NAME');
    EXCEPTION WHEN OTHERS THEN NULL; END;
  END IF;
END;
/


-- SHOW PARAMETER local_listener

The aq_ha_notifications => TRUE above lets the DB publish HA events. Some clients (OCI/ODP.NET) consume from AQ directly when notification=TRUE;
docs show the server-side bit typically via srvctl, but with DBMS_SERVICE the notification property is covered by AQ HA notifications.

For Java UCP clients, the most reliable approach is to also run ONS daemons on each DB host and point UCP at them:

$ORACLE_HOME/bin/onsctl start

In your JBoss/WebSphere datasource, set:
oracle.ons.nodes=dbprim:6200,dbstby1:6200,dbstby2:6200,dbstby3:6200
oracle.jdbc.fanEnabled=true

5) Client connect string stays the same

jdbc:oracle:thin:@(DESCRIPTION=
 (ADDRESS_LIST=(ADDRESS=(PROTOCOL=TCP)(HOST=dbprim)(PORT=1521))
               (ADDRESS=(PROTOCOL=TCP)(HOST=dbstby1)(PORT=1521)))
 (CONNECT_DATA=(SERVICE_NAME=app_tac)))


select name, failover_type, failover_restore, commit_outcome
from dba_services where name='APP_TAC';

Step 5: Enable ONS/FAN

On both DB nodes:
Add to $ORACLE_HOME/opmn/conf/ons.config (if standalone) or via srvctl modify service -notification TRUE
Ensure port (default 6200) is open.

Example on client:
export ONS_CONFIG="nodes=dbprim:6200,dbstby:6200"

Step 6: Configure Client with UCP + TAC
Edit swingconfig.xml connection string:
<connection-string>
  jdbc:oracle:thin:@(DESCRIPTION=
    (ADDRESS_LIST=
      (ADDRESS=(PROTOCOL=TCP)(HOST=dbprim)(PORT=1521))
      (ADDRESS=(PROTOCOL=TCP)(HOST=dbstby)(PORT=1521)))
    (CONNECT_DATA=(SERVICE_NAME=app_tac)))
</connection-string>

-- set properties for TAC
<property name="oracle.net.ns.SQLnetDef.TAC" value="true"/>
<property name="oracle.jdbc.fanEnabled" value="true"/>
<property name="oracle.jdbc.replayInitiationTimeout" value="1800"/>

-- start swingbench
./charbench -c ./swingconfig.xml -ucp -v users,tpm


Step 7: Validate Zero-Downtime Failover
DGMGRL> switchover to dbstby;
sudo pkill -9 -f pmon_dbprim
(FSFO wil auto failover in second-case)

Step 8: Transient Logical Standby Upgrade (for patch demo)
DGMGRL> convert database dbstby to snapshot standby;


🧩 2. Typical MAA Zero-Downtime Upgrade Flow with AutoUpgrade

Step 1  Primary: DBPRIM    | Version 19.15
         Standby: DBSTBY   | Version 19.15
         FSFO Observer running
         TAC Service: APP_TAC

Step 2  Prepare patched Oracle Home on standby host
         e.g. /u01/app/oracle/product/19.21.0/dbhome_2

Step 3  Convert standby to transient logical standby
         DGMGRL> convert database dbstby to snapshot standby;
         (or to transient logical using TLS script)

Step 4  Run AutoUpgrade on the standby (in deploy mode)
         java -jar $ORACLE_HOME/rdbms/admin/autoupgrade.jar \
              -config /home/oracle/autoupgrade_tls.cfg \
              -mode deploy

Step 5  Validate upgraded standby
         DGMGRL> convert database dbstby to physical standby;
         Redo apply resumes

Step 6  Perform switchover
         DGMGRL> switchover to dbstby;
         Clients continue via TAC with no outage

Step 7  Upgrade former primary using AutoUpgrade
         (same config file, different home path)

Step 8  Reinstate as standby
         DGMGRL> reinstate database dbprim;

🧰 3. Example AutoUpgrade Configuration for This Scenario

global.autoupg_log_dir=/u01/app/autoupgrade/logs
global.raise_compatibility=yes

upg1.source_home=/u01/app/oracle/product/19.15.0/dbhome_1
upg1.target_home=/u01/app/oracle/product/19.21.0/dbhome_2
upg1.sid=DBSTBY
upg1.log_dir=/u01/app/autoupgrade/dbstby
upg1.upgrade_node=dbstby
upg1.start_time=immediate
upg1.target_version=19.21
upg1.run_utlrp=yes
upg1.timezone_upg=yes
upg1.restoration=no

$ java -jar $ORACLE_HOME/rdbms/admin/autoupgrade.jar -config /home/oracle/autoupgrade_tls.cfg -mode deploy

5. Advanced Option — Use AutoUpgrade in “Dual Mode”

AutoUpgrade has a -mode deploy -n 2 syntax that lets you upgrade two databases sequentially —
e.g. first standby, then primary — using one config file.
This can fully automate the rolling upgrade sequence if combined with pre- and post-actions that call Data Guard switchover commands.


🎯 10. Example Demo Sequence (Scripted Overview)

# Prepare transient standby
dgmgrl sys@dbprim "convert database dbstby to transient logical standby"

# Run AutoUpgrade on dbstby
java -jar /u01/app/oracle/product/19.15.0/dbhome_1/rdbms/admin/autoupgrade.jar \
  -config /home/oracle/autoupgrade_tls.cfg -mode deploy

# Switchover after upgrade
dgmgrl sys@dbprim "switchover to dbstby"

# Run AutoUpgrade on old primary
java -jar /u01/app/oracle/product/19.15.0/dbhome_1/rdbms/admin/autoupgrade.jar \
  -config /home/oracle/autoupgrade_dbprim.cfg -mode deploy

# Reinstate and resume
dgmgrl sys@dbstby "reinstate database dbprim"





sqlplus scott/tiger@'(DESCRIPTION=
  (ADDRESS_LIST=
    (ADDRESS=(PROTOCOL=TCP)(HOST=dbprim)(PORT=1521))
    (ADDRESS=(PROTOCOL=TCP)(HOST=dbstby1)(PORT=1521)))
  (CONNECT_DATA=(SERVICE_NAME=app_tac)))'

SHOW USER;
SELECT SYS_CONTEXT('USERENV','SERVICE_NAME') FROM DUAL;
SELECT DATABASE_ROLE FROM V$DATABASE;



onsctl debug on


SELECT QUEUE_NAME, ENQUEUE_ENABLED, DEQUEUE_ENABLED FROM DBA_QUEUES WHERE QUEUE_NAME LIKE '%HA%';


import java.sql.*;
import oracle.ucp.jdbc.PoolDataSourceFactory;
import oracle.ucp.jdbc.PoolDataSource;

public class TacDemo {
  public static void main(String[] args) throws Exception {
    PoolDataSource pds = PoolDataSourceFactory.getPoolDataSource();
    pds.setConnectionFactoryClassName("oracle.jdbc.replay.OracleDataSourceImpl");
    pds.setURL("jdbc:oracle:thin:@(DESCRIPTION=(ADDRESS_LIST=(ADDRESS=(PROTOCOL=TCP)(HOST=dbprim)(PORT=1521))(ADDRESS=(PROTOCOL=TCP)(HOST=dbstby1)(PORT=1521)))(CONNECT_DATA=(SERVICE_NAME=app_tac)))");
    pds.setUser("scott");
    pds.setPassword("tiger");
    pds.setFastConnectionFailoverEnabled(true);  // enables FAN
    pds.setONSConfiguration("dbprim:6200,dbstby1:6200"); // adjust if needed

    try (Connection conn = pds.getConnection();
         Statement st = conn.createStatement()) {
      for (int i=0; i<100000; i++) {
        st.execute("INSERT INTO tac_test VALUES (" + i + ")");
        Thread.sleep(1000);
      }
    }
  }
}



